## 事务型MQ
在创建session时可以选择开启事务控制。所谓事务控制，即将消息生成发送，或接受，消费操作放入一个事务中。但不能同时控制发送与消费这一整个过程。因为事务都是基于一个session下的操作。

在事务状态下进行发送操作，消息并未真正投递到中间件，而只有进行`session.commit()`操作之后，消息才会发送到中间件，再转发到适当的消费者进行处理。如果是调用rollback操作，则表明，当前事务期间内所发送的消息都取消掉。此时无论commit或rollback，会重新打开一个事务。

## 问题
- 当存在多个消费者的时候，消费事务是如何保证的。一个有事务，一个无事务？？会存在这样的情况吗？

## 学习记录
1. 多次不能消费的消费会进入死信队列
2. 不能进行事务型和非事务型混合消费，否则后到的消费者不能消费信息
3. 只能存在一个事务型消费者？至多只有一个事务型消费者在消费？（没有相关概念，待确认）
4. 如果此session为事务类型,用户指定的ACK_MODE将被忽略,而强制使用"SESSION_TRANSACTED"类型
5. 如果session非事务类型时,也将不能将 ACK_MODE设定为"SESSION_TRANSACTED"
