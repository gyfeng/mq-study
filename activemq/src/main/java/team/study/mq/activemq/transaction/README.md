## 事务型MQ
在创建session时可以选择开启事务控制。所谓事务控制，即将消息生成发送，或接受，消费操作放入一个事务中。但不能同时控制发送与消费这一整个过程。因为事务都是基于一个session下的操作。

在事务状态下进行发送操作，消息并未真正投递到中间件，而只有进行`session.commit()`操作之后，消息才会发送到中间件，再转发到适当的消费者进行处理。如果是调用rollback操作，则表明，当前事务期间内所发送的消息都取消掉。此时无论commit或rollback，会重新打开一个事务。

## 问题
- 当存在多个消费者的时候，消费事务是如何保证的。一个有事务，一个无事务？？会存在这样的情况吗？